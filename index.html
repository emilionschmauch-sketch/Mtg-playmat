<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MAGIC Playmat</title>
<style>
:root{
  --bg:#081018;
  --panel:#0f2b25;
  --muted:#91a3ac;
  --white:#e6eef2;
  --accent:#0ea5a4;
  --danger:#ef4444;
  --card-w:88px;
  --card-h:122px;
  --small-w:60px;
  --small-h:82px;
  --zone-min-h:140px;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--white);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
.app{max-width:1300px;margin:0 auto;padding:12px;box-sizing:border-box;}
.header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px}
.header .title{font-size:18px;font-weight:600}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
textarea,input,button,select{font-family:inherit}
textarea#deckText{width:100%;min-height:90px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#f8fafb;color:#012}
.btn{background:#e6f6f5;color:#013;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;}
.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;color:var(--white)}
.small{padding:6px 8px;font-size:13px}
.row-stats{display:flex;gap:12px;align-items:center;margin-top:8px}
.stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;text-align:center;min-width:90px}
.stat .value{font-size:20px;margin:4px 0}
.layout{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
/* a column that expands downward; each column contains stacked zones */
.col{flex:1;min-width:240px;display:flex;flex-direction:column;gap:12px}

#zoomOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}
#zoomOverlay img {
  max-width: 90%;
  max-height: 90%;
  border: 4px solid white;
  border-radius: 8px;
}
#zoomOverlay.hidden { display: none; }

/* zones */
.zone{background:linear-gradient(180deg,var(--panel),#062e28);padding:10px;border-radius:10px;min-height:var(--zone-min-h);box-sizing:border-box;overflow:auto}
.zone-title{font-weight:600;margin-bottom:8px;color:var(--muted)}
.hand{display:flex;gap:8px;overflow:auto;padding:6px;min-height:110px}
.zone-list{display:flex;gap:6px;flex-wrap:wrap;align-items:flex-start}
.card{width:var(--card-w);height:var(--card-h);background-size:cover;background-position:center;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.6);position:relative;touch-action:none;transform-origin:center center;transition:transform 180ms ease}
.card.small{width:var(--small-w);height:var(--small-h)}
.card.tapped{transform:rotate(90deg)}
.counters{position:absolute;left:6px;bottom:6px;background:rgba(0,0,0,0.45);padding:3px 6px;border-radius:6px;font-size:12px}
.selected{outline:3px solid rgba(255,255,255,0.06)}
/* battlefield bigger and scrollable internal, clamp drag inside it */
.battle-wrap{min-height:520px;height:calc(60vh);background:linear-gradient(180deg,#073b34,#052b24);border-radius:8px;overflow:hidden;position:relative}
.battle-area{position:relative;width:100%;height:100%;overflow:hidden}
/* context menu */
.context-menu{position:fixed;background:#062b29;border:1px solid rgba(255,255,255,0.06);padding:10px;border-radius:10px;z-index:9999;min-width:240px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
.context-menu .menu-header{cursor:grab;padding:6px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.context-menu .menu-items{display:flex;flex-direction:column;gap:6px;max-height:60vh;overflow:auto}
.context-menu button, .context-menu input{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:6px;color:var(--white)}
.context-menu .row{display:flex;gap:6px;align-items:center}
.context-menu hr{border:none;border-top:1px solid rgba(255,255,255,0.04);margin:6px 0}

/* responsive */
@media (max-width:900px){
  .layout{flex-direction:column}
  .battle-wrap{height:50vh}
}

/* small helper */
.muted{color:var(--muted);font-size:13px}
.err{color:var(--danger);font-weight:600}
</style>
</head>
<body>
<div class="app" id="app">
  <div class="header">
    <div class="title">MAGIC Playmat</div>
    <div class="controls">
      <button id="undoBtn" class="ghost small" title="Annuler la dernière action">Undo</button>
      <button id="exportBtn" class="ghost small">Exporter état</button>
    </div>
  </div>

  <div>
    <label class="muted">Deck (textarea) ou importer (.txt / .csv)</label>
    <textarea id="deckText" placeholder="Ex : 4 Lightning Bolt"></textarea>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
      <input id="deckFile" type="file" accept=".txt,.csv" />
      <button id="loadDeck" class="btn">Charger Deck</button>
      <span id="loadStatus" class="muted" style="display:none">Chargement…</span>

      <button id="drawHand" class="btn">Main initiale</button>
      <button id="shuffleLib" class="btn">Mélanger</button>
      <button id="toggleHand" class="ghost small">Cacher main</button>
    </div>

    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="drawX" class="ghost small">Piocher X</button>
      <button id="millX" class="ghost small">Meuler X</button>
      <button id="tutorBtn" class="ghost small">Tutor (nom)</button>
      <button id="revealTop" class="ghost small">Révéler dessus</button>
    </div>
  </div>

  <div class="row-stats">
    <div class="stat"><div class="muted">Vie</div><div id="life" class="value">40</div><div style="display:flex;gap:6px;justify-content:center"><button id="lifePlus" class="ghost small">+1</button><button id="lifeMinus" class="ghost small">-1</button></div></div>
    <div class="stat"><div class="muted">Poison</div><div id="poison" class="value">0</div><div style="display:flex;gap:6px;justify-content:center"><button id="poisonPlus" class="ghost small">+1</button><button id="poisonMinus" class="ghost small">-1</button></div></div>
    <div style="margin-left:auto" class="muted">Deck: <span id="deckCount">0</span> — Bibliothèque: <span id="libCount">0</span></div>
  </div>

<div class="zone" id="handZone">
        <div class="zone-title">Main (<span id="handCount">0</span>)</div>
        <div id="hand" class="hand" aria-live="polite"></div>
      </div>
      <br>
  <div class="layout" id="layout">
    
    <!-- left column -->
    <div class="col">
      
      <div class="zone" id="graveZone">
        <div class="zone-title">Cimetière (<span id="graveCount">0</span>)</div>
        <div id="graveyard" class="zone-list"></div>
      </div>
      <div class="zone" id="exileZone">
        <div class="zone-title">Exil (<span id="exileCount">0</span>)</div>
        <div id="exile" class="zone-list"></div>
      </div>
    </div>

    <!-- center column (battlefield) -->
    <div class="col" style="flex:2">
      <div class="zone battle-wrap" id="battleWrap">
        <div class="zone-title">Champ de bataille (<span id="bfCount">0</span>)</div>
        <div id="battlefield" class="battle-area"></div>
      </div>
    </div>
<div id="zoomOverlay" class="hidden">
  <img id="zoomImage" src="" alt="zoom carte">
</div>

    <!-- right column -->
    <div class="col">
      <div class="zone" id="commandWrap" style="display:none">
        <div class="zone-title">Command Zone</div>
        <div id="commandZone" class="zone-list"></div>
      </div>

      <div class="zone" id="tokensZone">
        <div class="zone-title">Tokens disponibles (cliquer pour créer)</div>
        <div id="availableTokens" class="zone-list"></div>
      </div>

      <div class="zone" id="libraryZone" style="display:none">
        <div class="zone-title">Bibliothèque (masquée)</div>
        <div id="library" class="zone-list"></div>
      </div>

    </div>
  </div>

  <div id="errors" style="margin-top:8px"></div>
</div>

<script>
/* ===========================
   STATE
   =========================== */
const state = {
  deck: [],      // full deck objects
  library: [],   // cards in library (top at index 0)
  hand: [],
  battlefield: [],
  graveyard: [],
  exile: [],
  commandZone: [],
  tokensTemplates: [],
  tokens: []     // token objects (displayed on battlefield)
};
let undoStack = [];
const UNDO_LIMIT = 200;
let handHidden = false;

/* ===========================
   DOM shortcuts
   =========================== */
const $ = id => document.getElementById(id);
const deckText = $('deckText'), deckFile = $('deckFile'), loadBtn = $('loadDeck'), loadStatus = $('loadStatus'),
      drawHandBtn = $('drawHand'), mullBtn = $('mulligan'), shuffleBtn = $('shuffleLib'), toggleHandBtn = $('toggleHand'),
      handNode = $('hand'), battlefieldNode = $('battlefield'), graveNode = $('graveyard'), exileNode = $('exile'),
      commandWrap = $('commandWrap'), commandNode = $('commandZone'), availableTokensNode = $('availableTokens'),
      libraryNode = $('library'), libraryZone = $('libraryZone'),
      lifeNode = $('life'), poisonNode = $('poison'),
      deckCountNode = $('deckCount'), libCountNode = $('libCount'), handCountNode = $('handCount'),
      bfCountNode = $('bfCount'), graveCountNode = $('graveCount'), exileCountNode = $('exileCount'),
      errorsDiv = $('errors');

/* ===========================
   UTILS
   =========================== */
const uid = (p='id') => `${p}-${Math.random().toString(36).slice(2,9)}`;
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function pushUndo(action){
  undoStack.push(action);
  if(undoStack.length > UNDO_LIMIT) undoStack.shift();
  $('undoBtn').disabled = false;
}
function doUndo(){
  const act = undoStack.pop();
  if(!act){ alert('Rien à annuler'); return; }
  switch(act.type){
    case 'move': {
      // move back
      const {cardId, from, to, index} = act.data;
      moveCardById(cardId, to, from, true, index);
      break;
    }
    case 'create': {
      // remove created card (by id) from its zone
      removeCardById(act.data.cardId);
      break;
    }
    case 'counterAdd': {
      const {cardId, key, amount} = act.data;
      const c = findCardById(cardId); if(c){ c.counters[key] = (c.counters[key]||0) - amount; if(c.counters[key] <= 0) delete c.counters[key]; }
      break;
    }
    case 'counterRemove': {
      const {cardId, key, amount} = act.data;
      const c = findCardById(cardId); if(c){ c.counters[key] = (c.counters[key]||0) + amount; }
      break;
    }
    case 'draw': {
      // move last drawn back to top of library
      const {cards} = act.data;
      for(let i=cards.length-1;i>=0;i--){
        const id = cards[i].id;
        removeCardById(id);
        state.library.unshift(cards[i]);
      }
      break;
    }
    case 'mill': {
      const {cards} = act.data;
      // move from graveyard back to top of library
      for(let i=cards.length-1;i>=0;i--){
        const id = cards[i].id;
        removeCardById(id);
        state.library.unshift(cards[i]);
      }
      break;
    }
    default:
      console.warn('undo unsupported for', act.type);
  }
  renderAll();
  if(undoStack.length === 0) $('undoBtn').disabled = true;
}
$('undoBtn').addEventListener('click', doUndo);
$('undoBtn').disabled = true;

function findCardById(id){
  const zones = ['deck','library','hand','battlefield','graveyard','exile','commandZone','tokens'];
  for(const z of zones){
    if(z === 'tokens'){
      const t = state.tokens.find(c=>c.id===id); if(t) return t;
    } else {
      const a = state[z]; if(!a) continue;
      const c = a.find(x=>x.id===id); if(c) return c;
    }
  }
  return null;
}
function removeCardById(id){
  ['library','hand','battlefield','graveyard','exile','commandZone','tokens','deck'].forEach(z=>{
    const arr = state[z];
    if(!arr) return;
    const i = arr.findIndex(c=>c.id===id);
    if(i>-1) arr.splice(i,1);
  });
}

/* ===========================
   RENDER
   =========================== */
function updateCounts(){
  deckCountNode.textContent = state.deck.length;
  libCountNode.textContent = state.library.length;
  handCountNode.textContent = state.hand.length;
  bfCountNode.textContent = (state.battlefield.length + state.tokens.length);
  graveCountNode.textContent = state.graveyard.length;
  exileCountNode.textContent = state.exile.length;
  $('handCount').textContent = state.hand.length;
}

function makeCardElement(card){
  const el = document.createElement('div');
  el.className = 'card' + (card.isToken ? ' token' : '') + (card.tapped ? ' tapped' : '');
  el.style.backgroundImage = card.image ? `url(${card.image})` : 'linear-gradient(90deg,#444,#666)';
  el.dataset.id = card.id;
  el.dataset.name = card.name || '';
  // counters display
  if(card.counters){
    // will be rendered below in render.counters
  }
  return el;
}

function renderCountersOnEl(cardEl, card){
  // remove existing counters nodes
  cardEl.querySelectorAll('.counters').forEach(n=>n.remove());
  for(const [k,v] of Object.entries(card.counters||{})){
    const s = document.createElement('div'); s.className='counters'; s.textContent = `${k}: ${v}`; cardEl.appendChild(s);
  }
}

function renderHand(){
  handNode.innerHTML = '';
  for(const c of state.hand){
    const el = makeCardElement(c);
    el.classList.toggle('small', false);
    // event handlers
    el.addEventListener('click', ()=>{ moveCardById(c.id, 'hand', 'battlefield'); });
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openContextMenuForCard(e, c, 'hand'); });
    addLongPress(el, (e)=> openContextMenuForCard(e, c, 'hand'));
    renderCountersOnEl(el, c);
    handNode.appendChild(el);
  }
  if(handHidden){
    handNode.querySelectorAll('.card').forEach(img=> img.style.backgroundImage = 'url(https://cards.scryfall.io/back.png)');
  }
}

function renderBattlefield(){
  battlefieldNode.innerHTML = '';
  // create container area that has bounds
  const wrap = battlefieldNode;
  // place each battlefield card absolutely
  const all = state.battlefield.concat(state.tokens);
  for(const c of all){
    const el = makeCardElement(c);
    el.style.position = 'absolute';
    el.style.left = (c.x ?? 20) + 'px';
    el.style.top = (c.y ?? 20) + 'px';
    el.dataset.id = c.id;
    // interactions
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openContextMenuForCard(e, c, c.isToken ? 'tokens' : 'battlefield'); });
    addLongPress(el, (e)=> openContextMenuForCard(e, c, c.isToken ? 'tokens' : 'battlefield'));
    // double click tap
    el.addEventListener('dblclick', ()=>{ c.tapped = !c.tapped; renderAll(); });
    // drag within bounds
    attachPointerDrag(el, c, wrap);
    renderCountersOnEl(el, c);
    wrap.appendChild(el);
  }
}

function renderZonesSmall(){
  // graveyard
  graveNode.innerHTML = '';
  for(const c of state.graveyard){
    const el = makeCardElement(c); el.classList.add('small');
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openContextMenuForCard(e, c, 'graveyard'); });
    addLongPress(el, (e)=> openContextMenuForCard(e, c, 'graveyard'));
    renderCountersOnEl(el, c);
    graveNode.appendChild(el);
  }
  // exile
  exileNode.innerHTML = '';
  for(const c of state.exile){
    const el = makeCardElement(c); el.classList.add('small');
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openContextMenuForCard(e, c, 'exile'); });
    addLongPress(el, (e)=> openContextMenuForCard(e, c, 'exile'));
    renderCountersOnEl(el, c);
    exileNode.appendChild(el);
  }
  // command
  commandNode.innerHTML = '';
  for(const c of state.commandZone){
    const el = makeCardElement(c);
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openContextMenuForCard(e, c, 'commandZone'); });
    addLongPress(el, (e)=> openContextMenuForCard(e, c, 'commandZone'));
    renderCountersOnEl(el, c);
    commandNode.appendChild(el);
  }
  commandWrap.style.display = state.commandZone.length ? 'block' : 'none';

  // tokens templates
  availableTokensNode.innerHTML = '';
  for(const t of state.tokensTemplates){
    const el = makeCardElement(t); el.classList.add('small'); el.style.cursor = 'pointer';
    el.addEventListener('click', ()=>{ const tk = createTokenFromTemplate(t); state.tokens.push(tk); pushUndo({type:'create', data:{cardId:tk.id, to:'tokens'}}); renderAll(); });
    availableTokensNode.appendChild(el);
  }

  // library view hidden but we can show small preview if needed
  libraryNode.innerHTML = '';
  // keep library hidden by default (as requested)
}

function renderAll(){
  renderHand();
  renderBattlefield();
  renderZonesSmall();
  updateCounts();
}

/* ===========================
   DRAG (pointer) with clamp to battlefield bounds
   =========================== */
function attachPointerDrag(el, card, container){
  let dragging=null;
  el.addEventListener('pointerdown', (event)=>{
    event.preventDefault();
    el.setPointerCapture(event.pointerId);
    const rect = container.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    dragging = {
      pointerId: event.pointerId,
      startX: event.clientX, startY: event.clientY,
      origX: el.offsetLeft, origY: el.offsetTop,
      parentRect: rect
    };
  });
  window.addEventListener('pointermove', (event)=>{
    if(!dragging) return;
    const dx = event.clientX - dragging.startX;
    const dy = event.clientY - dragging.startY;
    const nx = dragging.origX + dx;
    const ny = dragging.origY + dy;
    // clamp inside container
    const maxX = dragging.parentRect.width - parseFloat(getComputedStyle(el).width);
    const maxY = dragging.parentRect.height - parseFloat(getComputedStyle(el).height);
    const clampedX = clamp(nx, 0, Math.max(0, maxX));
    const clampedY = clamp(ny, 0, Math.max(0, maxY));
    el.style.left = clampedX + 'px';
    el.style.top = clampedY + 'px';
    // update state position
    card.x = clampedX; card.y = clampedY;
  });
  window.addEventListener('pointerup', (event)=>{
    if(!dragging) return;
    try{ el.releasePointerCapture(dragging.pointerId); }catch(_){}
    dragging = null;
    // push move undo? we could store last move action but skip for simplicity
  });
}

/* ===========================
   CONTEXT MENU (draggable header; inputs accept keyboard)
   =========================== */
let currentMenu = null;
function openContextMenuForCard(event, cardObj, fromZone){
  // remove existing
  if(currentMenu){ currentMenu.remove(); currentMenu = null; }
  const menu = document.createElement('div'); menu.className = 'context-menu';
  // position centered near event (but keep within viewport)
  const x = event.pageX || (window.innerWidth / 2);
  const y = event.pageY || (window.innerHeight / 2);
  menu.style.left = x + 'px'; menu.style.top = y + 'px';
// --- Zoom preview ---
const zoomImg = document.getElementById('zoomImage');
zoomImg.src = cardObj.image || ''; 
document.getElementById('zoomOverlay').classList.remove('hidden');
document.getElementById('zoomOverlay').onclick = ()=> {
  document.getElementById('zoomOverlay').classList.add('hidden');
};

  // header (drag handle)
  const header = document.createElement('div'); header.className = 'menu-header'; header.innerHTML = `<div style="font-weight:600">${cardObj.name||'(sans nom)'}</div><div style="opacity:0.8">${fromZone}</div>`;
  menu.appendChild(header);

  const items = document.createElement('div'); items.className = 'menu-items';

  // Move targets
  const addMoveBtn = (label, dest) => {
    const b = document.createElement('button'); b.textContent = label;
    b.addEventListener('click', ()=>{ moveCardById(cardObj.id, fromZone, dest); closeMenu(); });
    items.appendChild(b);
  };
  addMoveBtn('→ Main','hand');
  addMoveBtn('→ Champ','battlefield');
  addMoveBtn('→ Cimetière','graveyard');
  addMoveBtn('→ Exil','exile');
  addMoveBtn('→ Command Zone','commandZone');
  addMoveBtn('Bibliothèque (dessus)','libraryTop');
  addMoveBtn('Bibliothèque (dessous)','libraryBottom');

  // Copy/token
  const copyBtn = document.createElement('button'); copyBtn.textContent = 'Créer copie/token';
  copyBtn.addEventListener('click', ()=>{ const copy = shallowCopyCard(cardObj); state.tokens.push(copy); pushUndo({type:'create', data:{cardId:copy.id, to:'tokens'}}); renderAll(); closeMenu(); });
  items.appendChild(copyBtn);

  items.appendChild(document.createElement('hr'));

  // +1/+1 add
  const addPlusRow = document.createElement('div'); addPlusRow.className='row';
  const plusInput = document.createElement('input'); plusInput.type='number'; plusInput.min='1'; plusInput.value='1'; plusInput.placeholder='x';
  const plusBtn = document.createElement('button'); plusBtn.textContent = 'Ajouter +1/+1';
  plusBtn.addEventListener('click', ()=>{ const n = Math.max(1, parseInt(plusInput.value)||1); cardObj.counters['+1/+1'] = (cardObj.counters['+1/+1']||0) + n; pushUndo({type:'counterAdd', data:{cardId:cardObj.id, key:'+1/+1', amount:n}}); renderAll(); closeMenu(); });
  addPlusRow.appendChild(plusInput); addPlusRow.appendChild(plusBtn); items.appendChild(addPlusRow);

  // custom marker
  const customRow = document.createElement('div'); customRow.className='row';
  const customName = document.createElement('input'); customName.placeholder='Nom marqueur';
  const customNum = document.createElement('input'); customNum.type='number'; customNum.min='1'; customNum.value='1'; customNum.style.width='72px';
  const customBtn = document.createElement('button'); customBtn.textContent='Ajouter';
  customBtn.addEventListener('click', ()=>{ const k = (customName.value||'').trim(); if(!k) { alert('Nom requis'); return; } const n = Math.max(1, parseInt(customNum.value)||1); cardObj.counters[k] = (cardObj.counters[k]||0) + n; pushUndo({type:'counterAdd', data:{cardId:cardObj.id, key:k, amount:n}}); renderAll(); closeMenu(); });
  customRow.appendChild(customName); customRow.appendChild(customNum); customRow.appendChild(customBtn);
  items.appendChild(customRow);

  // remove counters for existing keys
  const keys = Object.keys(cardObj.counters || {});
  if(keys.length){
    items.appendChild(document.createElement('hr'));
    keys.forEach(k=>{
      const row = document.createElement('div'); row.className='row';
      const num = document.createElement('input'); num.type='number'; num.min='1'; num.value='1'; num.style.width='72px';
      const btn = document.createElement('button'); btn.textContent = `Retirer ${k}`;
      btn.addEventListener('click', ()=>{ const n = Math.max(1, parseInt(num.value)||1); const prev = (cardObj.counters[k]||0); const removed = Math.min(prev, n); cardObj.counters[k] = prev - removed; if(cardObj.counters[k] <= 0) delete cardObj.counters[k]; pushUndo({type:'counterRemove', data:{cardId:cardObj.id, key:k, amount:removed}}); renderAll(); closeMenu(); });
      row.appendChild(num); row.appendChild(btn); items.appendChild(row);
    });
  }

  // if in command zone, allow exit
  if(fromZone === 'commandZone'){
    const exitBtn = document.createElement('button'); exitBtn.textContent = 'Sortir de Command Zone → Main';
    exitBtn.addEventListener('click', ()=>{ moveCardById(cardObj.id, 'commandZone', 'hand'); closeMenu(); });
    items.appendChild(exitBtn);
  }

  menu.appendChild(items);
  document.body.appendChild(menu);
  currentMenu = menu;

  // make draggable by header
  makeMenuDraggable(menu, header);

  // keep menu inside viewport if possible
  const r = menu.getBoundingClientRect();
  if(r.right > window.innerWidth) menu.style.left = (window.innerWidth - r.width - 8) + 'px';
  if(r.bottom > window.innerHeight) menu.style.top = (window.innerHeight - r.height - 8) + 'px';

  // stop clicks inside menu closing it
  menu.addEventListener('click', (event)=> event.stopPropagation());
  setTimeout(()=> document.addEventListener('click', closeMenuOnOutside, {once:true}), 10);
}
function closeMenuOnOutside(e){ if(currentMenu && !e.target.closest('.context-menu')){ currentMenu.remove(); currentMenu = null; } }
function closeMenu(){ if(currentMenu){ currentMenu.remove(); currentMenu = null; } }

function makeMenuDraggable(menu, handle){
  let dragging = null;
  handle.addEventListener('pointerdown', (e)=>{
    dragging = {startX:e.clientX, startY:e.clientY, origLeft: parseFloat(menu.style.left||0), origTop: parseFloat(menu.style.top||0)};
    function onMove(event){ if(!dragging) return; const dx = event.clientX - dragging.startX, dy = event.clientY - dragging.startY; menu.style.left = (dragging.origLeft + dx) + 'px'; menu.style.top = (dragging.origTop + dy) + 'px'; }
    function onUp(){ window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); dragging=null; }
    window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp);
  });
}

/* ===========================
   MOVE / COPY / ZONE LOGIC (state-based)
   =========================== */
function findAndRemoveById(id){
  for(const zone of ['library','hand','battlefield','graveyard','exile','commandZone','tokens','deck']){
    const arr = state[zone];
    if(!arr) continue;
    const idx = arr.findIndex(c=>c.id === id);
    if(idx > -1) return arr.splice(idx,1)[0];
  }
  return null;
}
function moveCardById(cardId, fromZone, toZone, isUndo=false, fromIndex){
  // find card object and remove from its current array
  const card = findAndRemoveById(cardId);
  if(!card) return;
  // destination
  let targetArr;
  if(toZone === 'hand') targetArr = state.hand;
  else if(toZone === 'battlefield') targetArr = state.battlefield;
  else if(toZone === 'graveyard') targetArr = state.graveyard;
  else if(toZone === 'exile') targetArr = state.exile;
  else if(toZone === 'commandZone') targetArr = state.commandZone;
  else if(toZone === 'libraryTop') { state.library.unshift(card); pushUndo({type:'move', data:{cardId:card.id, from:fromZone, to:toZone, index:fromIndex}}); renderAll(); return; }
  else if(toZone === 'libraryBottom') { state.library.push(card); pushUndo({type:'move', data:{cardId:card.id, from:fromZone, to:toZone, index:fromIndex}}); renderAll(); return; }
  else if(toZone === 'tokens') { state.tokens.push(card); pushUndo({type:'move', data:{cardId:card.id, from:fromZone, to:toZone, index:fromIndex}}); renderAll(); return; }
  else targetArr = state[toZone] || state.hand;

  targetArr.push(card);
  if(!isUndo) pushUndo({type:'move', data:{cardId:card.id, from:fromZone, to:toZone, index:fromIndex}});
  renderAll();
}

/* shallow copy for tokens */
function shallowCopyCard(card){
  const copy = {
    id: uid('copy'),
    name: card.name,
    image: card.image,
    raw: card.raw,
    counters: {...(card.counters||{})},
    tapped: false,
    isToken: true,
    x: (card.x||20) + 16,
    y: (card.y||20) + 16
  };
  return copy;
}

/* ===========================
   COUNTERS helpers (via menu)
   =========================== */
// See menu handlers above that modify card.counters and push undo entries

/* ===========================
   DRAW / MILL / TUTOR
   =========================== */
function drawX(n){
  if(n <= 0) return;
  const drawn = [];
  for(let i=0;i<n;i++){
    if(state.library.length === 0) break;
    const c = state.library.shift();
    state.hand.push(c);
    drawn.push(c);
  }
  if(drawn.length) pushUndo({type:'draw', data:{cards:drawn}});
  renderAll();
}
function millX(n){
  if(n <= 0) return;
  const milled = [];
  for(let i=0;i<n;i++){
    if(state.library.length === 0) break;
    const c = state.library.shift();
    state.graveyard.unshift(c);
    milled.push(c);
  }
  if(milled.length) pushUndo({type:'mill', data:{cards:milled}});
  renderAll();
}
function tutorByName(name){
  if(!name) return alert('Nom requis');
  const idx = state.library.findIndex(c=> (c.name||'').toLowerCase() === name.toLowerCase());
  if(idx > -1){ state.hand.push(state.library.splice(idx,1)[0]); renderAll(); return; }
  const idx2 = state.library.findIndex(c=> (c.name||'').toLowerCase().includes(name.toLowerCase()));
  if(idx2 > -1){ state.hand.push(state.library.splice(idx2,1)[0]); renderAll(); return; }
  alert('Carte non trouvée dans la bibliothèque.');
}

/* ===========================
   Scryfall fetch & deck load (supports CSV & TXT)
   =========================== */
async function fetchCardByName(name){
  const enc = s => encodeURIComponent(s);
  try{
    let r = await fetch(`https://api.scryfall.com/cards/named?exact=${enc(name)}`);
    let d = await r.json();
    if(d?.object === 'error'){
      r = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${enc(name)}`);
      d = await r.json();
    }
    if(d?.object === 'error') return {error:true, message:d?.details || 'not found'};
    return {error:false, data:d};
  }catch(e){ return {error:true, message:e.message || 'fetch error'}; }
}

function chooseImageFromData(data){
  return data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal || data.image_uris?.large || '';
}

$('drawHand').addEventListener('click', ()=> { if(state.library.length === 0) return alert('Bibliotheque vide'); drawX(7); });

deckFile.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (ev)=> deckText.value = ev.target.result;
  reader.readAsText(f);
});

$('loadDeck').addEventListener('click', async ()=>{
  const lines = deckText.value.split('\n').map(l=>l.trim()).filter(Boolean);
  if(lines.length === 0) return alert('Colle une decklist ou importe un fichier .txt/.csv');
  $('loadStatus').style.display = 'inline';
  errorsDiv.innerHTML = '';
  state.deck = []; state.library = []; state.hand=[]; state.battlefield=[]; state.graveyard=[]; state.exile=[]; state.commandZone=[]; state.tokensTemplates=[]; state.tokens=[];
  const errors = [];
  const tokenIds = new Set();
  for(const rawLine of lines){
    // support "4,Lightning Bolt" or "4 Lightning Bolt"
    let qty = 0, name = '';
    if(rawLine.includes(',')){
      const parts = rawLine.split(',');
      qty = parseInt(parts[0]);
      name = parts.slice(1).join(',').trim();
    } else {
      const m = rawLine.match(/^\s*(\d+)\s+(.+)$/);
      if(m){ qty = parseInt(m[1]); name = m[2]; }
    }
    if(!qty || !name){ errors.push(`Ligne non reconnue: "${rawLine}"`); continue; }
    // fetch scryfall
    const res = await fetchCardByName(name);
    if(res.error){ errors.push(`${name}: ${res.message}`); continue; }
    const data = res.data;
    // collect token parts
    if(Array.isArray(data.all_parts)){
      data.all_parts.forEach(p => { if(p.component === 'token') tokenIds.add(p.id); });
    }
    // create card objects
    for(let i=0;i<qty;i++){
      const c = {
        id: uid('card'),
        name: data.name || (data.card_faces?.[0]?.name) || name,
        image: chooseImageFromData(data),
        raw: data,
        counters: {},
        tapped: false,
        zone: 'deck', // initial
        x: 20 + Math.random() * 200,
        y: 20 + Math.random() * 200,
        isToken: false
      };
      state.deck.push(c);
    }
  }
  // fetch token templates
  for(const tid of tokenIds){
    try{
      const r = await fetch(`https://api.scryfall.com/cards/${encodeURIComponent(tid)}`);
      const d = await r.json();
      if(d && d.object !== 'error') state.tokensTemplates.push({ id: uid('tmpl'), name: d.name, image: chooseImageFromData(d), raw:d });
    }catch(e){ console.warn('token fetch error', e); }
  }
  // build library: shuffle deck
  state.library = shuffleArray(state.deck.slice());
  // ask commander
  const cmd = prompt('Nom du commandant (laisser vide si aucun) :');
  if(cmd && cmd.trim()){
    // try find in library
    const idx = state.library.findIndex(c => (c.name||'').toLowerCase() === cmd.trim().toLowerCase());
    if(idx > -1){
      const card = state.library.splice(idx,1)[0];
      state.commandZone.push(card);
      commandWrap.style.display = 'block';
    } else {
      // fuzzy search
      const idx2 = state.library.findIndex(c => (c.name||'').toLowerCase().includes(cmd.trim().toLowerCase()));
      if(idx2 > -1){
        const card = state.library.splice(idx2,1)[0];
        state.commandZone.push(card);
        commandWrap.style.display = 'block';
      } else {
        // try fetching if not present
        const fetched = await fetchCardByName(cmd.trim());
        if(!fetched.error){
          const d = fetched.data;
          const card = { id: uid('card'), name: d.name, image: chooseImageFromData(d), raw:d, counters:{}, tapped:false };
          state.commandZone.push(card);
          commandWrap.style.display = 'block';
        } else {
          commandWrap.style.display = 'none';
          alert('Commandant non trouvé (zone masquée).');
        }
      }
    }
  } else {
    commandWrap.style.display = 'none';
  }
  renderAll();
  if(errors.length) errorsDiv.innerHTML = '<div class="err">Erreurs :</div><ul style="color:#ffcccc">'+errors.map(e=>`<li>${e}</li>`).join('')+'</ul>';
  $('loadStatus').style.display = 'none';
});

/* ===========================
   UI handlers (draw/mill/tutor etc)
   =========================== */
$('drawX').addEventListener('click', ()=>{ const n = parseInt(prompt('Combien piocher ?', '1')); if(!n || n<=0) return; drawX(n); });
$('millX').addEventListener('click', ()=>{ const n = parseInt(prompt('Combien meuler ?', '1')); if(!n || n<=0) return; millX(n); });
$('tutorBtn').addEventListener('click', ()=>{ const name = prompt('Nom de la carte'); if(!name) return; tutorByName(name); });
$('revealTop').addEventListener('click', ()=>{ if(state.library.length === 0) return alert('Bibliothèque vide'); alert('Carte du dessus : ' + (state.library[0].name || '(sans nom)')); });
$('shuffleLib').addEventListener('click', ()=>{ state.library = shuffleArray(state.library); renderAll(); });

$('lifePlus').addEventListener('click', ()=> lifeNode.textContent = parseInt(lifeNode.textContent) + 1);
$('lifeMinus').addEventListener('click', ()=> lifeNode.textContent = parseInt(lifeNode.textContent) - 1);
$('poisonPlus').addEventListener('click', ()=> poisonNode.textContent = parseInt(poisonNode.textContent) + 1);
$('poisonMinus').addEventListener('click', ()=> poisonNode.textContent = parseInt(poisonNode.textContent) - 1);

$('toggleHand').addEventListener('click', ()=>{
  handHidden = !handHidden;
  $('toggleHand').textContent = handHidden ? 'Révéler main' : 'Cacher main';
  renderAll();
});

/* ===========================
   Tokens: create from template
   =========================== */
function createTokenFromTemplate(t){
  const tk = {
    id: uid('token'),
    name: t.name,
    image: t.image,
    counters: {},
    tapped: false,
    isToken: true,
    x: 24 + Math.random() * 140,
    y: 24 + Math.random() * 140
  };
  return tk;
}

/* ===========================
   helpers
   =========================== */
function shuffleArray(a){ const arr = a.slice(); for(let i=arr.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

/* ===========================
   Shortcuts for moving via menu: used by menu buttons
   =========================== */
// They call moveCardById(cardId, currentZone, destZone)

/* ===========================
   Long-press helper for mobile
   =========================== */
function addLongPress(node, callback, ms=600){
  let timer=null, moved=false;
  node.addEventListener('pointerdown', (e)=>{
    moved=false;
    timer = setTimeout(()=>{ callback(e); }, ms);
  });
  node.addEventListener('pointermove', ()=>{ moved=true; if(timer){ clearTimeout(timer); timer=null; } });
  node.addEventListener('pointerup', ()=>{ if(timer){ clearTimeout(timer); timer=null; } });
  node.addEventListener('pointercancel', ()=>{ if(timer){ clearTimeout(timer); timer=null; } });
}

/* ===========================
   helpers used by dynamic menu & actions
   =========================== */
function closeMenuIfOpen(){ if(currentMenu){ currentMenu.remove(); currentMenu = null; } }

/* ===========================
   find remove helpers (used earlier)
   =========================== */
function removeCardFromZoneArray(arr, id){
  const idx = arr.findIndex(c=>c.id===id); if(idx>-1){ const sp = arr.splice(idx,1)[0]; return sp; } return null;
}

/* ===========================
   remove generic
   =========================== */
function removeCardById(id){
  for(const z of ['library','hand','battlefield','graveyard','exile','commandZone','tokens','deck']){
    const a = state[z];
    if(!a) continue;
    const idx = a.findIndex(c=>c.id === id);
    if(idx>-1){ return a.splice(idx,1)[0]; }
  }
  return null;
}

/* ===========================
   initial render
   =========================== */
renderAll();

/* ===========================
   Export state
   =========================== */
$('exportBtn').addEventListener('click', ()=>{
  const exportObj = {...state};
  const blob = new Blob([JSON.stringify(exportObj,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'mtg-state.json'; a.click(); URL.revokeObjectURL(url);
});

/* ===========================
   Safe click outside to close menu
   =========================== */
document.addEventListener('click', (e)=>{ if(currentMenu && !e.target.closest('.context-menu')){ currentMenu.remove(); currentMenu=null; } });

/* ===========================
   Expose small API for console
   =========================== */
window._mtg = {
  state,
  renderAll,
  moveCardById,
  findCardById,
  removeCardById
};
</script>
</body>
</html>
